<!DOCTYPE html>
<html>
  <head>
    <title>Checkers</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-uWxY/CJNBR+1zjPWmfnSnVxwRheevXITnMqoEIeG1LJrdI0GlVs/9cVSyPYXdcSF"
      crossorigin="anonymous"
    />

    <link rel="stylesheet" href="about.css" />
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div style="isolation: isolate" class="about-section">
      <h1 style="font-family: courgette">Welcome</h1>
      <p></p>
      <p>
        This website is home to the game of checkers. You can choose to play
        either in single player or in multiplayer.
      </p>
      <p>
        There are three levels of difficulty which you can choose to play against,
        those being easy, moderate and difficult.
      </p>
      <p>
        There are two themes, light and dark, which you can adjust according to
        your preference at any time.
      </p>
    </div>

    <div
      id="abc"
      style="
        margin-left: auto;
        margin-top: 30px;
        text-align: center;
        align-items: center;
      "
    >
      <form action="/dashboard" method="POST">
        <input name="human_win" id="human_win" style="display: none" />
        <input name="m_m" id="m_m" style="display: none" />
        <input
          name="email"
          id="email"
          value="<%=email%>"
          style="display: none"
        />
        <button
          style="
            font-family: courgette;
            padding: 5px 15px;
            background-color: #614fc7;
          "
          type="button"
          class="btn btn-success"
          onclick="window.location.reload()"
        >
          <a
            style="
              color: rgb(255, 255, 255);
              font-size: 20px;
              text-decoration: none;
            "
            href="#defaultCanvas0"
            >New Game</a
          >
        </button>
        <button
          style="
            font-family: courgette;
            padding: 5px 15px;
            background-color: #614fc7;
            font-size: 20px;
            text-decoration: none;
          "
          type="submit"
          class="btn btn-success"
          id="submit_button"
        >
          <a
            style="
              color: rgb(255, 255, 255);
              font-size: 20px;
              text-decoration: none;
            "
          >
            Check score
          </a>
        </button>
        <button
          style="
            font-family: courgette;
            padding: 5px 15px;
            background-color: #614fc7;
            font-size: 20px;
            text-decoration: none;
          "
          type="button"
          class="btn btn-success"
          id="change_theme"
          value="undefined"
          onclick="change()"
        >
          Change Theme
        </button>
        <div class="dropdown" style="display: initial">
          <button
            class="btn btn-secondary dropdown-toggle"
            type="button"
            id="dropdownMenuButton1"
            data-bs-toggle="dropdown"
            style="
              font-family: courgette;
              padding: 5px 15px;
              background-color: #614fc7;
              font-size: 20px;
              text-decoration: none;
            "
          >
            Easy
          </button>
          <ul class="dropdown-menu" aria-labelledby="dropdownMenuButton1">
            <li selected>
              <a
                class="dropdown-item active"
                href="#"
                id="easy"
                onclick="easy()"
                >Easy</a
              >
            </li>
            <li>
              <a
                class="dropdown-item"
                href="#"
                id="moderate"
                onclick="moderate()"
                >Moderate</a
              >
            </li>
            <li>
              <a
                class="dropdown-item"
                href="#"
                id="difficult"
                onclick="difficult()"
                >Difficult</a
              >
            </li>
            <!-- <li>
              <a class="dropdown-item" href="#" id="expert" onclick="expert()"
                >Expert</a
              >
            </li> -->
          </ul>
        </div>
      </form>
    </div>

    <style>
      body {
        background-color: #aa3333;
      }
      p {
        font-family: "Nunito", sans-serif;
        font-size: 17px;
      }
      canvas {
        /* margin-bottom: 15px !important;; */
        display: block !important;
        margin: 15px auto !important;
      }
      /* body{
        background-color: #11aa44 !important;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400' viewBox='0 0 200 200'%3E%3Cg fill='none' stroke='%237F3' stroke-width='1' stroke-opacity='0.2'%3E%3Crect x='-40' y='40' width='75' height='75'/%3E%3Crect x='-35' y='45' width='65' height='65'/%3E%3Crect x='-30' y='50' width='55' height='55'/%3E%3Crect x='-25' y='55' width='45' height='45'/%3E%3Crect x='-20' y='60' width='35' height='35'/%3E%3Crect x='-15' y='65' width='25' height='25'/%3E%3Crect x='-10' y='70' width='15' height='15'/%3E%3Crect x='-5' y='75' width='5' height='5'/%3E%3Crect width='35' height='35'/%3E%3Crect x='5' y='5' width='25' height='25'/%3E%3Crect x='10' y='10' width='15' height='15'/%3E%3Crect x='15' y='15' width='5' height='5'/%3E%3Crect x='40' width='75' height='75'/%3E%3Crect x='45' y='5' width='65' height='65'/%3E%3Crect x='50' y='10' width='55' height='55'/%3E%3Crect x='55' y='15' width='45' height='45'/%3E%3Crect x='60' y='20' width='35' height='35'/%3E%3Crect x='65' y='25' width='25' height='25'/%3E%3Crect x='70' y='30' width='15' height='15'/%3E%3Crect x='75' y='35' width='5' height='5'/%3E%3Crect x='40' y='80' width='35' height='35'/%3E%3Crect x='45' y='85' width='25' height='25'/%3E%3Crect x='50' y='90' width='15' height='15'/%3E%3Crect x='55' y='95' width='5' height='5'/%3E%3Crect x='120' y='-40' width='75' height='75'/%3E%3Crect x='125' y='-35' width='65' height='65'/%3E%3Crect x='130' y='-30' width='55' height='55'/%3E%3Crect x='135' y='-25' width='45' height='45'/%3E%3Crect x='140' y='-20' width='35' height='35'/%3E%3Crect x='145' y='-15' width='25' height='25'/%3E%3Crect x='150' y='-10' width='15' height='15'/%3E%3Crect x='155' y='-5' width='5' height='5'/%3E%3Crect x='120' y='40' width='35' height='35'/%3E%3Crect x='125' y='45' width='25' height='25'/%3E%3Crect x='130' y='50' width='15' height='15'/%3E%3Crect x='135' y='55' width='5' height='5'/%3E%3Crect y='120' width='75' height='75'/%3E%3Crect x='5' y='125' width='65' height='65'/%3E%3Crect x='10' y='130' width='55' height='55'/%3E%3Crect x='15' y='135' width='45' height='45'/%3E%3Crect x='20' y='140' width='35' height='35'/%3E%3Crect x='25' y='145' width='25' height='25'/%3E%3Crect x='30' y='150' width='15' height='15'/%3E%3Crect x='35' y='155' width='5' height='5'/%3E%3Crect x='200' y='120' width='75' height='75'/%3E%3Crect x='40' y='200' width='75' height='75'/%3E%3Crect x='80' y='80' width='75' height='75'/%3E%3Crect x='85' y='85' width='65' height='65'/%3E%3Crect x='90' y='90' width='55' height='55'/%3E%3Crect x='95' y='95' width='45' height='45'/%3E%3Crect x='100' y='100' width='35' height='35'/%3E%3Crect x='105' y='105' width='25' height='25'/%3E%3Crect x='110' y='110' width='15' height='15'/%3E%3Crect x='115' y='115' width='5' height='5'/%3E%3Crect x='80' y='160' width='35' height='35'/%3E%3Crect x='85' y='165' width='25' height='25'/%3E%3Crect x='90' y='170' width='15' height='15'/%3E%3Crect x='95' y='175' width='5' height='5'/%3E%3Crect x='120' y='160' width='75' height='75'/%3E%3Crect x='125' y='165' width='65' height='65'/%3E%3Crect x='130' y='170' width='55' height='55'/%3E%3Crect x='135' y='175' width='45' height='45'/%3E%3Crect x='140' y='180' width='35' height='35'/%3E%3Crect x='145' y='185' width='25' height='25'/%3E%3Crect x='150' y='190' width='15' height='15'/%3E%3Crect x='155' y='195' width='5' height='5'/%3E%3Crect x='160' y='40' width='75' height='75'/%3E%3Crect x='165' y='45' width='65' height='65'/%3E%3Crect x='170' y='50' width='55' height='55'/%3E%3Crect x='175' y='55' width='45' height='45'/%3E%3Crect x='180' y='60' width='35' height='35'/%3E%3Crect x='185' y='65' width='25' height='25'/%3E%3Crect x='190' y='70' width='15' height='15'/%3E%3Crect x='195' y='75' width='5' height='5'/%3E%3Crect x='160' y='120' width='35' height='35'/%3E%3Crect x='165' y='125' width='25' height='25'/%3E%3Crect x='170' y='130' width='15' height='15'/%3E%3Crect x='175' y='135' width='5' height='5'/%3E%3Crect x='200' y='200' width='35' height='35'/%3E%3Crect x='200' width='35' height='35'/%3E%3Crect y='200' width='35' height='35'/%3E%3C/g%3E%3C/svg%3E") !important;
      } */
    </style>

    <script language="javascript" type="text/javascript" src="p5.js"></script>
    <script>
      // User module
      let ct = true;
      let m_m = document.getElementById("m_m");
      m_m.value = 0;
      m_m.innerHTML = 0;

      function change() {
        if (ct) {
          ct = false;
        } else {
          ct = true;
        }
        console.log(ct);
      }
      console.log(ct);

      t = setTimeout(2000, console.log("submit_button.click()"));
      clearTimeout(t);
      function htmlDecode(input) {
        var e = document.createElement("div");
        e.innerHTML = input;
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
      }
      var name = JSON.parse(htmlDecode("<%= JSON.stringify(name) %>"));
      /* Game of Checkers*/

      // board representation: array board with piece tables
      let board = [
        [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [-1, 0, 13, 0, 14, 0, 15, 0, 16, -1], // 7 row
        [-1, 17, 0, 18, 0, 19, 0, 20, 0, -1], // 6 row
        [-1, 0, 21, 0, 22, 0, 23, 0, 24, -1], // 5 row
        [-1, 0, 0, 0, 0, 0, 0, 0, 0, -1], // 4 row
        [-1, 0, 0, 0, 0, 0, 0, 0, 0, -1], // 3 row
        [-1, 1, 0, 2, 0, 3, 0, 4, 0, -1], // 2 row
        [-1, 0, 5, 0, 6, 0, 7, 0, 8, -1], // 1 row
        [-1, 9, 0, 10, 0, 11, 0, 12, 0, -1], // 0 row
        [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      ];

      let whitePieces = [
        { x: 0, y: 2, color: "W", captured: false, king: false }, // piece 1
        { x: 2, y: 2, color: "W", captured: false, king: false }, // piece 2
        { x: 4, y: 2, color: "W", captured: false, king: false }, // piece 3
        { x: 6, y: 2, color: "W", captured: false, king: false }, // piece 4
        { x: 1, y: 1, color: "W", captured: false, king: false }, // piece 5
        { x: 3, y: 1, color: "W", captured: false, king: false }, // piece 6
        { x: 5, y: 1, color: "W", captured: false, king: false }, // piece 7
        { x: 7, y: 1, color: "W", captured: false, king: false }, // piece 8
        { x: 0, y: 0, color: "W", captured: false, king: false }, // piece 9
        { x: 2, y: 0, color: "W", captured: false, king: false }, // piece 10
        { x: 4, y: 0, color: "W", captured: false, king: false }, // piece 11
        { x: 6, y: 0, color: "W", captured: false, king: false }, // piece 12
      ];

      let blackPieces = [
        { x: 1, y: 7, color: "B", captured: false, king: false }, // piece 13
        { x: 3, y: 7, color: "B", captured: false, king: false }, // piece 14
        { x: 5, y: 7, color: "B", captured: false, king: false }, // piece 15
        { x: 7, y: 7, color: "B", captured: false, king: false }, // piece 16
        { x: 0, y: 6, color: "B", captured: false, king: false }, // piece 17
        { x: 2, y: 6, color: "B", captured: false, king: false }, // piece 18
        { x: 4, y: 6, color: "B", captured: false, king: false }, // piece 19
        { x: 6, y: 6, color: "B", captured: false, king: false }, // piece 20
        { x: 1, y: 5, color: "B", captured: false, king: false }, // piece 21
        { x: 3, y: 5, color: "B", captured: false, king: false }, // piece 22
        { x: 5, y: 5, color: "B", captured: false, king: false }, // piece 23
        { x: 7, y: 5, color: "B", captured: false, king: false }, // piece 24
      ];

      let stackMoves = [];

      // program variables
      const WIDTH = 580;
      const SQUARE_WIDTH = WIDTH / 8;
      let performingMove = false; // whether a move animation is taking place
      let selectX = -1; // x position of last selected square
      let selectY = -1; // y position of last selected square

      // game state variables
      let whiteToMove = true; // whos turn it is
      let mustJump = false; // whether there is a jump to be made or not
      let lastJumpX = -1; // x-position of the last piece to jump
      let lastJumpY = -1; // y-position of the last piece to jump

      // game over variables
      let whiteWin = false;
      let blackWin = false;

      // players
      let whitePlayer = { ai: false };
      let blackPlayer = { ai: true };

      document.getElementById("human_win").innerHTML = "none";
      document.getElementById("human_win").value = undefined;

      function setup() {
        createCanvas(WIDTH, WIDTH);
        frameRate(60);
        textSize(64);
        textAlign(CENTER, CENTER);
        // request first move for AI
        requestMove();
        // draw first frame
        redraw();
      }

      function draw() {
        if (!thinking) {
          drawBoard();
          drawHighlights();
          drawMoves();

          drawWhitePieces();
          drawBlackPieces();

          drawVictoryMessage();
        }
      }
      function drawVictoryMessage() {
        // var x = myData[0].name;

        if (whiteWin) {
          document.getElementById("human_win").innerHTML = true;
          document.getElementById("human_win").value = true;

          fill(255);
          stroke(0);
          strokeWeight(5);
          text(`${name} Wins!`, WIDTH / 2, WIDTH / 2);
          strokeWeight(1);
        } else if (blackWin) {
          document.getElementById("human_win").innerHTML = false;
          document.getElementById("human_win").value = false;

          fill(0);
          stroke(255);
          strokeWeight(5);
          text("AI Wins!", WIDTH / 2, WIDTH / 2);
          // text("AI Wins!", WIDTH / 2, WIDTH / 2);
          strokeWeight(1);
          //console.log("winner is" + myData[0].name);
        }
      }

      // LISTENERS
      function mouseClicked() {
        if (!performingMove) {
          requestMove();
        }
      }

      // DRAW FUNCTIONS
      function drawWhitePieces() {
        for (const piece of whitePieces) {
          stroke(0);
          if (ct) fill(230, 0, 0);
          else fill(255);
          drawPiece(piece);
        }
      }

      function drawBlackPieces() {
        for (const piece of blackPieces) {
          stroke(124);
          if (ct) fill(0, 0, 255);
          else fill(0);
          drawPiece(piece);
        }
      }

      function drawPiece(piece) {
        if (!piece.captured) {
          const x = piece.x * SQUARE_WIDTH;
          const y = (7 - piece.y) * SQUARE_WIDTH;
          ellipse(
            x + SQUARE_WIDTH / 2,
            y + SQUARE_WIDTH / 2,
            SQUARE_WIDTH - 12,
            SQUARE_WIDTH - 12
          );
          if (piece.king) {
            noFill();
            stroke(247, 191, 51);
            rect(x + SQUARE_WIDTH / 2 - 10, y + SQUARE_WIDTH / 2 - 10, 20, 20);
          }
        }
      }

      function drawHighlights() {
        if (!performingMove) {
          if (
            hasPiece(selectX, selectY) &&
            whiteToMove === isWhite(selectX, selectY)
          ) {
            if (ct) fill(204, 204, 0);
            else fill(247, 191, 51);
            rect(
              selectX * SQUARE_WIDTH,
              (7 - selectY) * SQUARE_WIDTH,
              SQUARE_WIDTH,
              SQUARE_WIDTH
            );
          }

          noFill();
          if (ct) stroke(255, 255, 255);
          else stroke(0, 255, 0);
          if (whiteToMove && !whitePlayer.ai) {
            for (const piece of whitePieces) {
              if (!piece.captured && isMoveableWhite(piece.x, piece.y)) {
                rect(
                  piece.x * SQUARE_WIDTH + 4,
                  (7 - piece.y) * SQUARE_WIDTH + 4,
                  SQUARE_WIDTH - 8,
                  SQUARE_WIDTH - 8
                );
              }
            }
          } else if (!whiteToMove && !blackPlayer.ai) {
            for (const piece of blackPieces) {
              if (!piece.captured && isMoveableBlack(piece.x, piece.y)) {
                rect(
                  piece.x * SQUARE_WIDTH + 4,
                  (7 - piece.y) * SQUARE_WIDTH + 4,
                  SQUARE_WIDTH - 8,
                  SQUARE_WIDTH - 8
                );
              }
            }
          }
        }
      }

      function drawMoves() {
        noStroke();
        if (
          hasPiece(selectX, selectY) &&
          whiteToMove === isWhite(selectX, selectY)
        ) {
          let moves = getMoves(selectX, selectY);
          if (ct) fill(255, 255, 0, 200);
          else fill(247, 191, 51, 200);
          for (const move of moves) {
            ellipse(
              move.toX * SQUARE_WIDTH + SQUARE_WIDTH / 2,
              (7 - move.toY) * SQUARE_WIDTH + SQUARE_WIDTH / 2,
              SQUARE_WIDTH / 5,
              SQUARE_WIDTH / 5
            );
          }
        }
      }

      function drawBoard() {
        stroke(0, 255, 0);
        let whiteFirst = true;
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (ct) whiteFirst ? fill(214, 214, 194) : fill(0, 0, 0);
            else whiteFirst ? fill(207, 167, 110) : fill(102, 62, 15);
            whiteFirst = !whiteFirst;
            rect(
              i * SQUARE_WIDTH,
              j * SQUARE_WIDTH,
              SQUARE_WIDTH,
              SQUARE_WIDTH
            );
          }
          whiteFirst = !whiteFirst;
        }
      }

      // MOVE GENERATION
      function getAllMoves() {
        if (whiteToMove) {
          return getAllMovesWhite();
        } else {
          return getAllMovesBlack();
        }
      }

      function getAllMovesWhite() {
        let moves = getAllCapturesWhite();
        if (moves.length === 0) {
          for (const piece of whitePieces) {
            if (!piece.captured) {
              addMovesInDirection(moves, piece, 1, 1, "B");
              addMovesInDirection(moves, piece, -1, 1, "B");
              if (piece.king) {
                addMovesInDirection(moves, piece, 1, -1, "B");
                addMovesInDirection(moves, piece, -1, -1, "B");
              }
            }
          }
        }
        return moves;
      }

      function getAllMovesBlack() {
        let moves = getAllCapturesBlack();
        if (moves.length === 0) {
          for (const piece of blackPieces) {
            if (!piece.captured) {
              addMovesInDirection(moves, piece, 1, -1, "W");
              addMovesInDirection(moves, piece, -1, -1, "W");
              if (piece.king) {
                addMovesInDirection(moves, piece, 1, 1, "W");
                addMovesInDirection(moves, piece, -1, 1, "W");
              }
            }
          }
        }
        return moves;
      }

      function getMoveCountWhite() {
        return getAllMovesWhite().length;
      }

      function getMoveCountBlack() {
        return getAllMovesBlack().length;
      }

      function getAllCaptures() {
        if (whiteToMove) {
          return getAllCapturesWhite();
        } else {
          return getAllCapturesBlack();
        }
      }

      function getAllCapturesWhite() {
        let moves = [];
        if (lastJumpX !== -1) {
          let piece = getPiece(lastJumpX, lastJumpY);
          addMovesInDirection(moves, piece, 1, 1, "B");
          addMovesInDirection(moves, piece, -1, 1, "B");
          if (piece.king) {
            addMovesInDirection(moves, piece, 1, -1, "B");
            addMovesInDirection(moves, piece, -1, -1, "B");
          }
        }
        return moves;
      }

      function getAllCapturesBlack() {
        let moves = [];
        if (lastJumpX !== -1) {
          let piece = getPiece(lastJumpX, lastJumpY);
          addMovesInDirection(moves, piece, 1, -1, "W");
          addMovesInDirection(moves, piece, -1, -1, "W");
          if (piece.king) {
            addMovesInDirection(moves, piece, 1, 1, "W");
            addMovesInDirection(moves, piece, -1, 1, "W");
          }
        }
        return moves;
      }

      function getMoves(x, y) {
        if (isWhite(x, y)) {
          return getMovesWhite(x, y);
        } else if (isBlack(x, y)) {
          return getMovesBlack(x, y);
        }
      }

      function getMovesWhite(x, y) {
        let moves = [];
        let piece = getPiece(x, y);
        addMovesInDirection(moves, piece, 1, 1, "B");
        addMovesInDirection(moves, piece, -1, 1, "B");
        if (piece.king) {
          addMovesInDirection(moves, piece, 1, -1, "B");
          addMovesInDirection(moves, piece, -1, -1, "B");
        }
        return moves;
      }

      function getMovesBlack(x, y) {
        let moves = [];
        let piece = getPiece(x, y);
        addMovesInDirection(moves, piece, 1, -1, "W");
        addMovesInDirection(moves, piece, -1, -1, "W");
        if (piece.king) {
          addMovesInDirection(moves, piece, 1, 1, "W");
          addMovesInDirection(moves, piece, -1, 1, "W");
        }
        return moves;
      }

      function addMovesInDirection(moves, piece, dirX, dirY, col) {
        const x = piece.x;
        const y = piece.y;
        if (hasPiece(x + dirX, y + dirY)) {
          // if has piece
          const toJump = getPiece(x + dirX, y + dirY);
          if (toJump.color === col && isBlank(x + 2 * dirX, y + 2 * dirY)) {
            // if can jump piece
            moves.push({
              fromX: x,
              fromY: y,
              toX: x + 2 * dirX,
              toY: y + 2 * dirY,
              wasKing: piece.king,
              state: getState(),
              killNum: getNum(x + dirX, y + dirY),
              score: NaN,
              ordder: NaN,
            });
          }
        } else if (isBlank(x + dirX, y + dirY) && !mustJump) {
          // if is blank
          moves.push({
            fromX: x,
            fromY: y,
            toX: x + dirX,
            toY: y + dirY,
            wasKing: piece.king,
            state: getState(),
            killNum: -1,
            score: NaN,
            order: NaN,
          });
        }
      }

      function getMoveablePieces() {
        if (whiteToMove) {
          return getMoveablePiecesWhite();
        } else {
          return getMoveablePiecesBlack();
        }
      }

      function getMoveablePiecesWhite() {
        let movables = [];
        for (const piece of whitePieces) {
          if (isMoveableWhite(piece.x, piece.y)) {
            movables.push(piece);
          }
        }
        return movables;
      }

      function getMoveablePiecesBlack() {
        let movables = [];
        for (const piece of blackPieces) {
          if (isMoveableBlack(piece.x, piece.y)) {
            movables.push(piece);
          }
        }
        return movables;
      }

      function isMoveable(x, y) {
        if (isWhite(x, y)) {
          return isMoveableWhite(x, y);
        } else if (isBlack(x, y)) {
          return isMoveableBlack(x, y);
        }
      }

      function isMoveableWhite(x, y) {
        if (isMoveableInDirection(x, y, 1, 1, "B")) return true;
        if (isMoveableInDirection(x, y, -1, 1, "B")) return true;
        if (getPiece(x, y).king) {
          if (isMoveableInDirection(x, y, 1, -1, "B")) return true;
          if (isMoveableInDirection(x, y, -1, -1, "B")) return true;
        }
        return false;
      }

      function isMoveableBlack(x, y) {
        if (isMoveableInDirection(x, y, 1, -1, "W")) return true;
        if (isMoveableInDirection(x, y, -1, -1, "W")) return true;
        if (getPiece(x, y).king) {
          if (isMoveableInDirection(x, y, 1, 1, "W")) return true;
          if (isMoveableInDirection(x, y, -1, 1, "W")) return true;
        }
        return false;
      }

      function isMoveableInDirection(x, y, dirX, dirY, col) {
        if (hasPiece(x + dirX, y + dirY)) {
          // if has piece
          const piece = getPiece(x + dirX, y + dirY);
          if (piece.color === col && isBlank(x + 2 * dirX, y + 2 * dirY)) {
            // if can jump piece
            return true;
          }
        } else if (isBlank(x + dirX, y + dirY) && !mustJump) {
          // if is blank
          return true;
        }
        return false;
      }

      function mustJumpWhite() {
        if (lastJumpX !== -1) {
          let piece = getPiece(lastJumpX, lastJumpY);
          if (mustJumpInDirection(piece.x, piece.y, 1, 1, "B")) return true;
          if (mustJumpInDirection(piece.x, piece.y, -1, 1, "B")) return true;
          if (piece.king) {
            if (mustJumpInDirection(piece.x, piece.y, 1, -1, "B")) return true;
            if (mustJumpInDirection(piece.x, piece.y, -1, -1, "B")) return true;
          }
        } else {
          for (const piece of whitePieces) {
            if (!piece.captured) {
              if (mustJumpInDirection(piece.x, piece.y, 1, 1, "B")) return true;
              if (mustJumpInDirection(piece.x, piece.y, -1, 1, "B"))
                return true;
              if (piece.king) {
                if (mustJumpInDirection(piece.x, piece.y, 1, -1, "B"))
                  return true;
                if (mustJumpInDirection(piece.x, piece.y, -1, -1, "B"))
                  return true;
              }
            }
          }
        }
        return false;
      }

      function mustJumpBlack() {
        if (lastJumpX !== -1) {
          let piece = getPiece(lastJumpX, lastJumpY);
          if (mustJumpInDirection(piece.x, piece.y, 1, -1, "W")) return true;
          if (mustJumpInDirection(piece.x, piece.y, -1, -1, "W")) return true;
          if (piece.king) {
            if (mustJumpInDirection(piece.x, piece.y, 1, 1, "W")) return true;
            if (mustJumpInDirection(piece.x, piece.y, -1, 1, "W")) return true;
          }
        } else {
          for (const piece of blackPieces) {
            if (!piece.captured) {
              if (mustJumpInDirection(piece.x, piece.y, 1, -1, "W"))
                return true;
              if (mustJumpInDirection(piece.x, piece.y, -1, -1, "W"))
                return true;
              if (piece.king) {
                if (mustJumpInDirection(piece.x, piece.y, 1, 1, "W"))
                  return true;
                if (mustJumpInDirection(piece.x, piece.y, -1, 1, "W"))
                  return true;
              }
            }
          }
        }
        return false;
      }

      function mustJumpInDirection(x, y, dirX, dirY, col) {
        if (hasPiece(x + dirX, y + dirY)) {
          // if has piece
          const piece = getPiece(x + dirX, y + dirY);
          if (piece.color === col && isBlank(x + 2 * dirX, y + 2 * dirY)) {
            // if can jump piece
            return true;
          }
        }
        return false;
      }

      // GAME INTERACTION FUNCTIONS
      function requestMove() {
        if (
          (whiteToMove && !whitePlayer.ai) ||
          (!whiteToMove && !blackPlayer.ai)
        ) {
          let moves = undefined;
          if (whiteToMove && isWhite(selectX, selectY)) {
            moves = getMovesWhite(selectX, selectY);
          } else if (!whiteToMove && isBlack(selectX, selectY)) {
            moves = getMovesBlack(selectX, selectY);
          }

          selectX = Math.floor(mouseX / SQUARE_WIDTH);
          selectY = 7 - Math.floor(mouseY / SQUARE_WIDTH);

          if (typeof moves !== "undefined") {
            for (const move of moves) {
              if (selectX === move.toX && selectY === move.toY) {
                performMove(move);
              }
            }
          }
        } else {
          makeBestMove();
        }
      }

      function performMove(move) {
        if (whiteToMove) {
          m_m.value = parseInt(m_m.value) + 1;
          m_m.innerHTML = parseInt(m_m.innerHTML) + 1;
          console.log(m_m.value, "innerHtml: ", m_m.innerHTML);
        }
        performingMove = true;
        let piece = getPiece(move.fromX, move.fromY);
        let start = Date.now();
        const duration = 500;
        let timer = setInterval(function () {
          let timePassed = Date.now() - start;
          if (timePassed >= duration) {
            clearInterval(timer);
            movePiece(piece, move);
            checkVictory();
            switchTurns();
            return;
          }
          piece.x = lerp(move.fromX, move.toX, timePassed / duration);
          piece.y = lerp(move.fromY, move.toY, timePassed / duration);
        }, 0);
      }

      function movePiece(piece, move) {
        // move the piece's location
        piece.x = move.toX;
        piece.y = move.toY;
        let value = board[8 - move.fromY][move.fromX + 1];
        board[8 - move.fromY][move.fromX + 1] = 0;
        board[8 - move.toY][move.toX + 1] = value;

        // kill jumped piece
        if (move.killNum !== -1) {
          let kill = getPieceByNum(move.killNum);
          kill.captured = true;
          board[8 - kill.y][kill.x + 1] = 0;
          lastJumpX = move.toX;
          lastJumpY = move.toY;
        }

        // conditionally promote piece
        if (piece.color === "W" && piece.y === 7) {
          piece.king = true;
        } else if (piece.color === "B" && piece.y === 0) {
          piece.king = true;
        }

        stackMoves.push(move);
      }

      function performUnmove(move) {
        performingMove = true;
        let piece = getPiece(move.toX, move.toY);
        let start = Date.now();
        const duration = 100;
        let timer = setInterval(function () {
          let timePassed = Date.now() - start;
          if (timePassed >= duration) {
            clearInterval(timer);
            unmovePiece(piece, move);
            performingMove = false;
            playbackGame();
            return;
          }
          piece.x = lerp(move.toX, move.fromX, timePassed / duration);
          piece.y = lerp(move.toY, move.fromY, timePassed / duration);
        }, 0);
      }

      function unmovePiece(piece, move) {
        // move the piece's location back
        piece.x = move.fromX;
        piece.y = move.fromY;
        let value = board[8 - move.toY][move.toX + 1];
        board[8 - move.toY][move.toX + 1] = 0;
        board[8 - move.fromY][move.fromX + 1] = value;

        // revive jumped piece
        if (move.killNum !== -1) {
          let kill = getPieceByNum(move.killNum);
          kill.captured = false;
          board[8 - kill.y][kill.x + 1] = move.killNum;
        }

        // un-promote piece
        piece.king = move.wasKing;

        // rollback game state
        whiteWin = false;
        blackWin = false;
        setState(move.state);
      }

      function switchTurns() {
        selectX = -1;
        selectY = -1;
        performingMove = false;
        if (!isMoveable(lastJumpX, lastJumpY)) {
          // if there isn't a jump chain, then switch turns
          whiteToMove = !whiteToMove;
          lastJumpX = -1;
          lastJumpY = -1;
          mustJump = whiteToMove ? mustJumpWhite() : mustJumpBlack();
        }
        setTimeout(function () {
          requestMove();
        }, 100); // after current player has moved, request move on behalf of the AI
      }

      function playbackGame() {
        selectX = -1;
        selectY = -1;
        if (stackMoves.length > 0) {
          performUnmove(stackMoves.pop());
        }
      }

      function checkVictory() {
        let temp = mustJump;
        mustJump = false; // must be set to avoid strange results
        if (isWinWhite()) {
          console.log("White");
          whiteWin = true;
          setTimeout(function () {
            playbackGame();
          }, 1000);
        } else if (isWinBlack()) {
          console.log("Black");
          blackWin = true;
          setTimeout(function () {
            playbackGame();
          }, 1000);
        }
        mustJump = temp;
      }

      function isWinWhite() {
        for (const piece of blackPieces) {
          // white can only win when black has no pieces or no moves on his turn
          if (
            !piece.captured &&
            (isMoveableBlack(piece.x, piece.y) || !whiteToMove)
          ) {
            return false;
          }
        }
        return true;
      }

      function isWinBlack() {
        for (const piece of whitePieces) {
          // black can only win when white has no pieces or no moves on his turn
          if (
            (!piece.captured && isMoveableWhite(piece.x, piece.y)) ||
            whiteToMove
          ) {
            return false;
          }
        }
        return true;
      }

      // UTILITY FUNCTIONS
      function getPiece(x, y) {
        const num = board[8 - y][x + 1];
        if (num >= 1 && num <= 12) {
          return whitePieces[num - 1];
        } else if (num >= 13 && num <= 24) {
          return blackPieces[num - 12 - 1];
        }
      }

      function getPieceByNum(num) {
        if (num >= 1 && num <= 12) {
          return whitePieces[num - 1];
        } else if (num >= 13 && num <= 24) {
          return blackPieces[num - 12 - 1];
        }
      }

      function hasPiece(x, y) {
        const num = board[8 - y][x + 1];
        return num >= 1 && num <= 24;
      }

      function isOutOfBounds(x, y) {
        const num = board[8 - y][x + 1];
        return num === -1;
      }

      function isBlank(x, y) {
        const num = board[8 - y][x + 1];
        return num === 0;
      }

      function isWhite(x, y) {
        const num = board[8 - y][x + 1];
        return num >= 1 && num <= 12;
      }

      function isBlack(x, y) {
        const num = board[8 - y][x + 1];
        return num >= 13 && num <= 24;
      }

      function isKing(x, y) {
        return getPiece(x, y).king;
      }

      function getNum(x, y) {
        return board[8 - y][x + 1];
      }

      function colorOf(x, y) {
        if (isWhite(x, y)) {
          return "W";
        } else if (isBlack(x, y)) {
          return "B";
        }
      }

      function getState() {
        return {
          whiteToMove: whiteToMove,
          mustJump: mustJump,
          lastJumpX: lastJumpX,
          lastJumpY: lastJumpY,
        };
      }

      function setState(state) {
        whiteToMove = state.whiteToMove;
        mustJump = state.mustJump;
        lastJumpX = state.lastJumpX;
        lastJumpY = state.lastJumpY;
      }
    </script>

    <script>
      /* Checkers Engine */
      // Given a board at a specific instance in time and a color, returns the best move for that color

      const positionValuesWhite = [
        [0, 5, 0, 5, 0, 5, 0, 5],
        [4, 0, 2, 0, 2, 0, 3, 0],
        [0, 3, 0, 1, 0, 2, 0, 4],
        [4, 0, 2, 0, 1, 0, 3, 0],
        [0, 3, 0, 1, 0, 2, 0, 4],
        [4, 0, 2, 0, 2, 0, 3, 0],
        [0, 3, 0, 3, 0, 3, 0, 4],
        [4, 0, 6, 0, 6, 0, 6, 0],
      ];
      const positionValuesBlack = [
        [0, 6, 0, 6, 0, 6, 0, 4],
        [4, 0, 3, 0, 3, 0, 3, 0],
        [0, 3, 0, 2, 0, 2, 0, 4],
        [4, 0, 2, 0, 1, 0, 3, 0],
        [0, 3, 0, 1, 0, 2, 0, 4],
        [4, 0, 2, 0, 1, 0, 3, 0],
        [0, 3, 0, 2, 0, 2, 0, 4],
        [5, 0, 5, 0, 5, 0, 5, 0],
      ];

      let e = document.getElementById("easy");
      let m = document.getElementById("moderate");
      let d = document.getElementById("difficult");
      // let ex = document.getElementById("expert");
      let dropdownMenuButton1 = document.getElementById("dropdownMenuButton1");
      let lvl = document.getElementById("lvl");

      let maxDepth = 2;

      function easy() {
        maxDepth = 2;
        dropdownMenuButton1.innerHTML = "Easy";
        console.log("easy", maxDepth);
      }
      function moderate() {
        maxDepth = 6;
        dropdownMenuButton1.innerHTML = "Moderate";
        console.log("moderate", maxDepth);
      }
      function difficult() {
        maxDepth = 10;
        dropdownMenuButton1.innerHTML = "Difficult";
        console.log("difficult", maxDepth);
      }
      // function expert() {
      //   maxDepth = 11;
      //   dropdownMenuButton1.innerHTML="Expert";
      //   console.log("expert", maxDepth);
      // }

      let thinking = false;
      let skipTurn = false;
      let tt = { table: new Map(), EXACT: 1, LOWERBOUND: 2, UPPERBOUND: 3 };
      let zobristTable = []; // W = 1, WK = 2, B = 3, BK = 4
      let zobristHash = 0;
      initZobrist();
      let num_cutoffs = 0;

      // function makeRandomMove() {
      //     let moves = getAllMoves();
      //     if(moves.length !== 0) {
      //         const moveIdx = Math.floor(moves.length * Math.random());
      //         performMove(moves[moveIdx]);
      //     }
      // }

      function getBestMove(evaluatedMoves) {
        return evaluatedMoves.reduce((prev, curr) => {
          if (curr.score > prev.score) {
            return curr;
          } else {
            return prev;
          }
        });
      }

      function makeBestMove() {
        thinking = true;
        resetZobristHash();
        let initialMoves = getAllMoves();
        if (initialMoves.length !== 0) {
          if (initialMoves.length === 1) {
            performMove(initialMoves[0]);
            console.log("score: " + evaluate().toFixed(1));
          } else {
            let bestMove;
            for (let curDepth = 1; curDepth <= maxDepth; curDepth++) {
              num_cutoffs = 0;
              negamax(initialMoves, curDepth, -Infinity, Infinity);
              bestMove = getBestMove(initialMoves);
              // debug log - depth
              console.log(
                `depth: ${curDepth} - (${bestMove.fromX}, ${bestMove.fromY}) to (${bestMove.toX}, ${bestMove.toY})`
              );
            }
            performMove(bestMove);
            //debug log - score +  cut-offs
            console.log("cutoffs: " + num_cutoffs);
            console.log("score: " + bestMove.score.toFixed(1));
          }
        }
        thinking = false;
      }

      function orderMoves(moves) {
        return moves;
      }

      function generateMoves(initialMoves) {
        return initialMoves !== null ? initialMoves : getAllMoves();
      }

      // Negamax with Alpha-Beta Pruning and Transposition Table Lookup
      function negamax(initialMoves, depth, alpha, beta) {
        if (!skipTurn) {
          let alphaOrig = alpha;

          let ttEntry = getTransposition();
          if (ttEntry !== undefined && ttEntry.depth >= depth) {
            if (ttEntry.flag === tt.EXACT) {
              return ttEntry.value;
            } else if (ttEntry.flag === tt.LOWERBOUND) {
              alpha = Math.max(alpha, ttEntry.value);
            } else if (ttEntry.flag === tt.UPPERBOUND) {
              beta = Math.min(beta, ttEntry.value);
            }

            if (alpha >= beta) {
              num_cutoffs++;
              return ttEntry.value;
            }
          }

          if (depth === 0 || whiteWin || blackWin) {
            return quiesce(-beta, -alpha);
          }
          let moves = generateMoves(initialMoves);
          moves = orderMoves(moves);
          for (const move of moves) {
            make(move);
            let bestScore = -negamax(null, depth - 1, -beta, -alpha);
            if (bestScore >= alpha) {
              alpha = bestScore;
              if (initialMoves != null) {
                move.score = bestScore;
              }
            }
            unmake(move);
            if (alpha >= beta) {
              num_cutoffs++;
              break;
            }
          }

          let ttDepth = ttEntry === undefined ? -1 : ttEntry.depth;
          if (
            ttDepth === -1
            // || depth >= ttDepth
          ) {
            let ttNew = { value: alpha, flag: tt.EXACT, depth: depth };
            if (ttNew.value <= alphaOrig) {
              ttNew.flag = tt.UPPERBOUND;
            } else if (ttNew.value >= beta) {
              ttNew.flag = tt.LOWERBOUND;
            }
            putTransposition(ttNew);
          }

          return alpha;
        } else {
          skipTurn = false;
          return -negamax(null, depth, -beta, -alpha);
        }
      }

      // Quiescence Search
      function quiesce(alpha, beta) {
        let score = evaluate();
        if (score >= beta) return score;

        let captures = getAllCaptures();
        for (const capture of captures) {
          make(capture);
          score = -quiesce(-beta, -alpha);
          unmake(capture);
          if (score >= alpha) {
            alpha = score;
            if (score >= beta) break;
          }
        }

        return score;
      }

      function make(move) {
        updateZobrist(move.fromX, move.fromY); // remove old position from hash
        // move the piece's location
        let piece = getPiece(move.fromX, move.fromY);
        piece.x = move.toX;
        piece.y = move.toY;
        let value = board[8 - move.fromY][move.fromX + 1];
        board[8 - move.fromY][move.fromX + 1] = 0;
        board[8 - move.toY][move.toX + 1] = value;

        // kill jumped piece
        if (move.killNum !== -1) {
          let kill = getPieceByNum(move.killNum);
          updateZobrist(kill.x, kill.y); // remove killed piece from hash
          kill.captured = true;
          board[8 - kill.y][kill.x + 1] = 0;
          lastJumpX = move.toX;
          lastJumpY = move.toY;
        }

        // conditionally promote piece
        if (piece.color === "W" && piece.y === 7) {
          piece.king = true;
        } else if (piece.color === "B" && piece.y === 0) {
          piece.king = true;
        }
        updateZobrist(move.toX, move.toY); // add new position to hash

        // check victory
        let temp = mustJump;
        mustJump = false;
        if (isWinWhite()) {
          whiteWin = true;
        } else if (isWinBlack()) {
          blackWin = true;
        }
        mustJump = temp;

        // check if jump chain
        if (!isMoveable(lastJumpX, lastJumpY)) {
          whiteToMove = !whiteToMove;
          lastJumpX = -1;
          lastJumpY = -1;
          mustJump = whiteToMove ? mustJumpWhite() : mustJumpBlack();
        } else if (lastJumpX !== -1) {
          skipTurn = true;
        }

        changeSidesZobrist();
      }

      function unmake(move) {
        updateZobrist(move.toX, move.toY); // remove old position from hash
        // move the piece's location back
        let piece = getPiece(move.toX, move.toY);
        piece.x = move.fromX;
        piece.y = move.fromY;
        let value = board[8 - move.toY][move.toX + 1];
        board[8 - move.toY][move.toX + 1] = 0;
        board[8 - move.fromY][move.fromX + 1] = value;

        // revive jumped piece
        if (move.killNum !== -1) {
          let kill = getPieceByNum(move.killNum);
          kill.captured = false;
          board[8 - kill.y][kill.x + 1] = move.killNum;
          updateZobrist(kill.x, kill.y); // add new piece to hash
        }

        // un-promote piece
        piece.king = move.wasKing;
        updateZobrist(move.fromX, move.fromY); // add new position to hash

        // rollback game state
        whiteWin = false;
        blackWin = false;
        setState(move.state);

        changeSidesZobrist();
      }

      function evaluate() {
        let color = whiteToMove ? 1 : -1;
        if (whiteWin) return color * 999;
        if (blackWin) return color * -999;

        let whiteScore = 0;
        for (const piece of whitePieces) {
          if (!piece.captured) {
            whiteScore += 1;
            whiteScore += positionValuesWhite[7 - piece.y][piece.x] / 20;
            if (piece.king) whiteScore += 1;
          }
        }

        let blackScore = 0;
        for (const piece of blackPieces) {
          if (!piece.captured) {
            blackScore += 1;
            blackScore += positionValuesBlack[7 - piece.y][piece.x] / 20;
            if (piece.king) blackScore += 1;
          }
        }

        whiteScore += getMoveCountWhite() / 100;
        blackScore += getMoveCountBlack() / 100;

        return color * (whiteScore - blackScore);
      }

      // Transposition Table Helper Functions
      function getTransposition() {
        return tt.table.get(zobristHash);
      }

      function putTransposition(ttEntry) {
        return tt.table.set(zobristHash, ttEntry);
      }

      // Zobrist Hashing Helper Functions
      function initZobrist() {
        zobristTable.changeSidesHash = getRandom32Bit();
        for (let x = 0; x < 8; x++) {
          zobristTable.push([]);
          for (let y = 0; y < 8; y++) {
            zobristTable[x].push([]);
            zobristTable[x][y].push(getRandom32Bit());
            zobristTable[x][y].push(getRandom32Bit());
            zobristTable[x][y].push(getRandom32Bit());
            zobristTable[x][y].push(getRandom32Bit());
          }
        }
        resetZobristHash();
      }

      function resetZobristHash() {
        for (let x = 0; x < 8; x++) {
          for (let y = 0; y < 8; y++) {
            updateZobrist(x, y);
          }
        }
      }

      function getRandom32Bit() {
        let num32 = Math.floor(2 * (Math.random() - 0.5) * 0x7fffffff);
        return num32 | 0;
      }

      function updateZobrist(x, y) {
        if (hasPiece(x, y)) {
          let kingOffset = isKing(x, y) ? 1 : 0;
          let zobristIdx = (isWhite(x, y) ? 0 : 2) + kingOffset;
          zobristHash = zobristHash ^ zobristTable[x][y][zobristIdx];
        }
      }

      function changeSidesZobrist() {
        zobristHash = zobristHash ^ zobristTable.changeSidesHash;
      }
    </script>
    <script
      language="javascript"
      type="text/javascript"
      src="index.js"
    ></script>
  </body>
</html>
